name: Deploy Infrastructure and Run Ansible a

on:
  push:
    branches:
      - main
  workflow_dispatch:

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ass2-test

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: AWS CLI - Configure
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region: us-east-1
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq ansible unzip

      - name: Create SSH Key File
        run: |
          mkdir -p ~/.ssh  # Ensure the .ssh directory exists
          cd ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > new_id_rsa  # Store the private key
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > new_id_rsa.pub  # Store the public key
          chmod 600 new_id_rsa  # Secure the private key file
          chmod 644 new_id_rsa.pub  # Set correct permissions for the public key
        shell: bash
        
      - name: Create Terraform variable file
        working-directory: ./src/infra
        run: |
          cat <<EOL > ./you.auto.tfvars
          path_to_ssh_public_key="~/.ssh/new_id_rsa.pub"
          my_ip_address="${{ secrets.IP_ADDRESS }}"
          allow_all_ip_addresses_to_access_database_server=true
          EOL
      
      - name: Check if S3 Bucket Exists
        id: check_s3
        run: |
          if aws s3api head-bucket --bucket "s4115252-s4115477-s3bucket" 2>/dev/null; then
            echo "S3 bucket exists."
            echo "skip_terraform_misc=true" >> $GITHUB_ENV
          else
            echo "S3 bucket does not exist."
            echo "skip_terraform_misc=false" >> $GITHUB_ENV
          fi

      - name: Check if DynamoDB Table Exists
        id: check_dynamodb
        run: |
          if aws dynamodb describe-table --table-name "foostatelock" 2>/dev/null; then
            echo "DynamoDB table exists."
            echo "skip_terraform_misc=true" >> $GITHUB_ENV
          else
            echo "DynamoDB table does not exist."
            echo "skip_terraform_misc=false" >> $GITHUB_ENV
          fi

      - name: Check if EC2 Instances Exist
        id: check_ec2
        run: |
          db_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=db" --query "Reservations[*].Instances[*].InstanceId" --output text | wc -w)
          app1_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=app1" --query "Reservations[*].Instances[*].InstanceId" --output text | wc -w)
          app2_count=$(aws ec2 describe-instances --filters "Name=tag:Name,Values=app2" --query "Reservations[*].Instances[*].InstanceId" --output text | wc -w)

          if [ "$db_count" -gt 0 ] && [ "$app1_count" -gt 0 ] && [ "$app2_count" -gt 0 ]; then
            echo "All EC2 instances exist."
            echo "skip_terraform_infra=true" >> $GITHUB_ENV
          else
            echo "One or more EC2 instances are missing."
            echo "skip_terraform_infra=false" >> $GITHUB_ENV
          fi
  

      # Initialize, Validate, and Apply Terraform (Misc)
      - name: Initialize, Validate, and Apply Terraform (Misc)
        if: env.skip_terraform_misc == 'false'
        working-directory: src/misc
        run: |
          terraform init --upgrade
          terraform validate
          terraform apply --auto-approve

      # Initialize and Validate Terraform (Infra)
      - name: Initialize, Validate, and Apply Terraform (Infra)
        if: env.skip_terraform_infra == 'false'
        working-directory: src/infra
        run: |
          terraform init --migrate-state
          terraform validate
      
      # Plan Terraform (Infra)
      - name: Plan Terraform (Infra)
        if: env.skip_terraform_infra == 'false'
        working-directory: src/infra
        id: terraform_plan_infra
        run: terraform plan -out=tfplan-infra
        continue-on-error: true

      # Apply Terraform (Infra) if Changes
      - name: Apply Terraform (Infra) if Changes
        if: env.skip_terraform_infra == 'false' && steps.terraform_plan_infra.outcome == 'success'
        working-directory: src/infra
        run: terraform apply --auto-approve tfplan-infra

      - name: Capture Terraform Outputs
        id: terraform_output
        if: env.skip_terraform_infra == 'false'
        working-directory: src/infra
        run: |
          echo "db_private_ip=$(terraform output -json vm_ip_addresses | jq -r '.db.private_ip_address')" >> $GITHUB_ENV
          echo "app1_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.app1.public_ip_address')" >> $GITHUB_ENV
          echo "app2_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.app2.public_ip_address')" >> $GITHUB_ENV
          echo "db_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.db.public_ip_address')" >> $GITHUB_ENV

      - name: Wait for Cloud-Init Completion on App and DB Servers
        if: env.skip_terraform_infra == 'false'
        run: |
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.app1_public_ip }} "cloud-init status -w"
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.app2_public_ip }} "cloud-init status -w"
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.db_public_ip }} "cloud-init status -w"

      - name: Generate Ansible inventory files
        working-directory: src/ansible
        run: |
          cat <<EOL > app1.yml
          app1_servers:
            hosts:
              app1:
                ansible_host: '${{ env.app1_public_ip }}'
          EOL
          cat <<EOL > app2.yml
          app2_servers:
            hosts:
              app2:
                ansible_host: '${{ env.app2_public_ip }}'
          EOL
          cat <<EOL > db.yml
          db_servers:
            hosts:
              db1:
                ansible_host: '${{ env.db_public_ip }}'
          EOL
          
      - name: Run Ansible db Playbook
        if: env.skip_terraform_infra == 'false'
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for the database"
          ansible-playbook db-playbook.yml -i db.yml --private-key ~/.ssh/new_id_rsa
  
      - name: Run Ansible app1 Playbook
        if: env.skip_terraform_infra == 'false'
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for app1"
          ansible-playbook app1-playbook.yml -i app1.yml --private-key ~/.ssh/new_id_rsa --extra-vars "db_hostname=${{ env.db_private_ip }}"

      - name: Run Ansible app2 Playbook
        if: env.skip_terraform_infra == 'false'
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for app2"
          ansible-playbook app2-playbook.yml -i app2.yml --private-key ~/.ssh/new_id_rsa --extra-vars "db_hostname=${{ env.db_private_ip }}"

      - name: Finalize
        run: echo "Deployment completed successfully!"
  