name: Deploy Infrastructure and Run Ansible a

on:
  push:
    branches:
      - main

jobs:
  deploy:
    runs-on: ubuntu-latest
    environment: ass2-test

    steps:
      - name: Checkout repository
        uses: actions/checkout@v2

      - name: AWS CLI - Configure
        uses: aws-actions/configure-aws-credentials@v3
        with:
          aws-region: us-east-1
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-session-token: ${{ secrets.AWS_SESSION_TOKEN }}

      - name: Install dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y jq ansible unzip
      - name: Create SSH Key File
        run: |
          mkdir -p ~/.ssh  # Ensure the .ssh directory exists
          cd ~/.ssh
          echo "${{ secrets.SSH_PRIVATE_KEY }}" > new_id_rsa  # Store the private key
          echo "${{ secrets.SSH_PUBLIC_KEY }}" > new_id_rsa.pub  # Store the public key
          chmod 600 new_id_rsa  # Secure the private key file
          chmod 644 new_id_rsa.pub  # Set correct permissions for the public key
        shell: bash

      - name: Create Terraform variable file
        working-directory: ./src/infra
        run: |
          cat <<EOL > ./you.auto.tfvars
          path_to_ssh_public_key="~/.ssh/new_id_rsa.pub"
          my_ip_address="${{ secrets.IP_ADDRESS }}"
          allow_all_ip_addresses_to_access_database_server=true
          EOL
          
      - name: Initialize and Validate Terraform (Misc)
        working-directory: src/misc
        run: |
          terraform init --upgrade
          terraform validate
  
      - name: Plan Terraform (Misc)
        working-directory: src/misc
        id: terraform_plan_misc
        run: terraform plan -out=tfplan-misc
        continue-on-error: true

      - name: Apply Terraform (Misc) if Changes
        working-directory: src/misc
        if: steps.terraform_plan_misc.outcome == 'success'
        run: terraform apply --auto-approve tfplan-misc

      - name: Initialize and Validate Terraform (Infra)
        working-directory: src/infra
        run: |
          terraform init --migrate-state
          terraform validate

      - name: Plan Terraform (Infra)
        working-directory: src/infra
        id: terraform_plan_infra
        run: terraform plan -out=tfplan-infra
        continue-on-error: true

      - name: Apply Terraform (Infra) if Changes
        working-directory: src/infra
        if: steps.terraform_plan_infra.outcome == 'success'
        run: terraform apply --auto-approve tfplan-infra      

      - name: Capture Terraform Outputs
        id: terraform_output
        working-directory: src/infra
        run: |
          echo "db_private_ip=$(terraform output -json vm_ip_addresses | jq -r '.db.private_ip_address')" >> $GITHUB_ENV
          echo "app1_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.app1.public_ip_address')" >> $GITHUB_ENV
          echo "app2_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.app2.public_ip_address')" >> $GITHUB_ENV
          echo "db_public_ip=$(terraform output -json vm_ip_addresses | jq -r '.db.public_ip_address')" >> $GITHUB_ENV

      - name: Wait for Cloud-Init Completion on App and DB Servers
        run: |
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.app1_public_ip }} "cloud-init status -w"
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.app2_public_ip }} "cloud-init status -w"
          ssh -o "StrictHostKeyChecking no" -i ~/.ssh/new_id_rsa ubuntu@${{ env.db_public_ip }} "cloud-init status -w"

      - name: Generate Ansible inventory files
        working-directory: src/ansible
        run: |
          cat <<EOL > app1.yml
          app1_servers:
            hosts:
              app1:
                ansible_host: '${{ env.app1_public_ip }}'
          EOL
          cat <<EOL > app2.yml
          app2_servers:
            hosts:
              app2:
                ansible_host: '${{ env.app2_public_ip }}'
          EOL
          cat <<EOL > db.yml
          db_servers:
            hosts:
              db1:
                ansible_host: '${{ env.db_public_ip }}'
          EOL
          
      - name: Run Ansible db Playbook
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for the database"
          ansible-playbook db-playbook.yml -i db.yml --private-key ~/.ssh/new_id_rsa
  
      - name: Run Ansible app1 Playbook
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for app1"
          ansible-playbook app1-playbook.yml -i app1.yml --private-key ~/.ssh/new_id_rsa --extra-vars "db_hostname=${{ env.db_private_ip }}"

      - name: Run Ansible app2 Playbook
        working-directory: src/ansible
        run: |
          echo "Running Ansible playbook for app2"
          ansible-playbook app2-playbook.yml -i app2.yml --private-key ~/.ssh/new_id_rsa --extra-vars "db_hostname=${{ env.db_private_ip }}"


      - name: Finalize
        run: echo "Deployment completed successfully!"